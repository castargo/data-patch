# Shell cheat sheets

## Горячие клавиши
* ```Ctrl + Alt + T``` - открыть консоль
* ```Ctrl + Shift + T``` - новая вкладка в терминале
* ```Ctrl + Shift + C / V``` - работа с текстом в терминале
* ```Ctrl + H``` - показать / скрыть скрытые файлы
* ```Ctrl + R``` - поиск по ранее выполненным командам
* ```Alt + <TAB>``` - переключение между открытыми приложениями
* ```Ctrl + <TAB>``` - переключение по вкладкам браузера
* ```Ctrl + L``` - аналогично команде clear
* ```Ctrl + R``` - поиск в истории команд в обратном порядке

## UNIX
* 1983 - Ричард Стокман анонсировал GNU
* 1991 - Линус Торвальд зарелизил первую версию ядра Linux Kernel

Linux - это **ядро**

Дистрибутив - это ОС, включающая в себя:
* Ядро Linux
* Библиотеки и утилиты
* Приложения
* Программы для установки и конфигурационные файлы системы

Системы пакетов:
* Debian (.deb) - Debian, Ubuntu, Mint, Raspbian
* Red Hat (.rpm) - Fedora, CentOS, Red Hat Linux

## Оболочка Linux
Shell (терминал, консоль, командная строка) - командная оболочка - программа, которая принимает команды, введенные с клавиатуры, и передает их ОС для выполнения.

На Linux, по умолчанию, язык оболочки называется BASH (Bourne Again Shell или улучшенный sh - первоначальная командная оболочка для Unix).
Bash - командная оболочка из проекта GNU.

Gnome-terminal или просто terminal - эмулятор терминала для взаимодействия пользователя с командной оболочкой.
* ```$``` - shell prompt - приглашение к вводу
* ```#``` - сеанс суперпользователя (sudo)
* ```clear``` - очистка экрана
* ```history``` - выводит содержимое истории команд
  * ```history | less```
  * ```history | grep /user/bin```
* ```reset``` - сброс терминала
* ```exit``` - выход из терминала

**Структура команды:** ```<команда> -<ключ> <значение>```

Командой в UNIX бывают:
* Встроенные команды (shell builtins)
* Функции командной оболочки (shell functions)
* Исполняемый файл, например, .exe
* Псевдонимы (alias)

Информация о командах:
* ```type <команда>``` - получение типа команды
* ```which``` - определение местоположения выполняемого файла
```help <команда>``` - справка для встроенной команды
* ```<команда> --help``` - вывод инструкции по использованию
* ```man <команда>``` - мануал (справочное руководство) по команде
* ```apropos <ключевое слово>``` - вывод списка подходящих команд
* ```whatis <команда>``` - краткое описание команды

Командная оболочка хранит в окружении:
* Переменные:
  * Переменные командной оболочки - данные, инициализируемые командой bash
  * Переменные окружения - все остальное
  * ```printenv | less``` - вывод переменных окружения
  * ```set | less``` - вывод переменных командной оболочки и переменных окружения
  * Вывод одной конкретной переменной:
    * ```printenv USER```
    * ```echo $HOME```
* Псевдонимы (alias)
  * ```alias``` - вывод списка псевдонимов (пользовательских команд)
  * ```alias имя='строка'``` - настройка пользовательской команды
  * ```alias foo='cd /usr; ls; cd -'```
  * ```unalis foo``` - удаление alias
* Функции командной оболочки

Сеансы работы с командной оболочкой:
* logging shell session (сеанс командной оболочки входа)
  * Файлы запуска:
    * /etc/profile
    * **~/.bash_profile** - личный пользовательский файл запуска
    * ~/.bash_login
    * ~/.profile
* non-logging shell session (простой сеанс командной оболочки)
  * Файлы запуска:
    * /etc/bash.bashrc
    * **~/.bashrc** - личный пользовательский файл запуска

```
# Изменить строку приглашения к вводу
echo "PS1='\[\e[1;33m\]\u@\h \w ->\n\[\e[1;36m\] \@ \d\$\[\e[m\] '
# Добавить пользовательскую команду
alias gs='git status '
# Записать изменения в ~/.bashrc
" >> ~/.bashrc

# Применить изменения в текущей сессии терминала
source ~/.bashrc

# Добавит директорию в переменную $PATH
export PATH=<dir>:"$PATH"

# Применить изменения в текущей сессии терминала (способ 2)
. .bashrc
```

## Вывод информации о системе
* ```whoami``` - имя пользователя
* ```uptime``` - состояние системы
* ```uname -a``` - информация о ядре ОС
* ```lsb_release -a``` - информация об ОС
* ```yelp``` - руководство пользователя Ubuntu

## Остановка системы
* ```halt``` - остановить
* ```poweroff``` - выключить питание
* ```reboot``` - перезагрузить
* ```shutdown``` - объединение первых трех + можно указать время:
  * ```sudo shutdown -h now``` - остановка
  * ```sudo shutdown -r now``` - перезагрузка

## Привилегии
[Chmod Calculator](https://chmodcommand.com/)

Unix - многопользовательская ОС. Пользователи могут объединяться в группы.

```id``` - выводит информацию об идентичности пользователя (uid, grid, groups)
* ```etc/password``` - файл, хранящий учетные записи пользователей
* ```etc/group``` - файл, хранящий информацию о группах
* ```etc/shadow``` - файл, хранящий информацию о пароле пользователя

Права доступа к файлам и каталогам определяются в терминах прав на чтение, запись и выполнения:
```
ls -l foo.txt
# -rw-rw-r--   1       me       me        100       2018-03-06  14:52       foo.txt
# Права      Число  Владелец  Группа     Размер     Дата и время           имя файла
# доступа    жестких         владельца    файла     последнего изменения
# к файлу    ссылок
#            на файл
```

Первый из символов в правах доступа к файлу определяет тип файла:
* ```-``` - обычный файл
* ```d``` - каталог
* ```l``` - символическая ссылка
* ```c``` - специальный файл символьного устройства
* ```b``` - специальный файл блочного устройства

<p align="center">
  <img width="400" src="pictures/chmod.png"/>
</p>

**chmod** - изменяет режим доступа (права) к файлу или каталогу. Изменять режим доступа может только владелец или суперпользователь.

Команда chmod поддерживает 2 способа изменения режима:
* При помощи восьмеричных чисел
  * ```chmod 777 file.txt```
  * Три цифры:
    * Owner Rights (u)
    * Group Rights (g)
    * Others Rights (o)
  * Наиболее распространенные разрешения: 700, 755, 777
* При помощи символьного представления:
  * ```chmod +x my_scr.sh```
  * для кого устанавливается разрешения
    * u - user - владелец
    * g - группа
    * o - все остальные
    * a - all
  * какие операции с разрешениями будут выполняться (r, w, x)
  * на какие разрешения эти операции будут влиять

**umask** - определение разрешения доступа к файлам по умолчанию, которые устанавливаются для файла при его создании.

**chown** - изменение владельца и группы файла

**chgrp** - изменение группы файла

**chown** - изменение группы файла

## Изменение идентичности

```passwd``` - изменение пароля пользователя

Есть 3 способа изменения идентичности пользователя:
1. Выйти из системы и войти с учетными данными другого пользователя.
2. Воспользоваться командой **su**.
3. Воспользоваться командой **sudo**.

**su** - запускает командную оболочку от имени другого пользователя.
* ```su [- [|]] <пользователь>```
* ```su -``` - суперпользователь
* ```su -с <команда>```

**sudo** - запускает командную оболочку от имени суперпользователя.
* ```sudo <команда>```
* sudo не запускает новую командную оболочку и не загружает окружение другого пользователя
* ```sudo -l``` - показывает, какие привилегии дает команда sudo

## Навигация и исследование системы
Директория в Unix считается типом файла.

* ```pwd``` - print working directory (вывести текущую директорию)
* ```cd <dir>``` - переход в другую директорию
  * ```cd ./``` - перейти в ту же директорию :)
  * ```cd -``` - перейти в предыдущий рабочий каталог
* ```ls <dir>``` - показать содержимое папки
  * ```ls -l <dir>``` - длинный формат вывода
  * ```ls -a <dir>``` - показать все файлы и папки (включая скрытые)
  * ```ls -A <dir>``` - almost all (не выводит . и ..)
  * ```ls -t <dir>``` - сортировать по времени
  * ```ls -d <dir>``` - информация о каталоге, а не его содержимом
  * ```ls -S <dir>``` - сортировать по размеру

Пути:
* Абсолютные - начинается с корневого каталога и перечисляет ветви дерева до файла или каталога.
* Относительные - начинается в рабочем (текущем) каталоге (с . или ..)

Псевдонимы директорий:
* ```.``` - текущая директория 
* ```..``` - родительская директория
* ```~``` - домашняя директория пользователя
* ```/``` - корневая директория системы: [назначение основных директорий в файловой системе Linux](https://admin-gu.ru/os/linux/naznacheniya-onovnykh-katalogov-direktorij-papok-v-fajlovoj-sisteme-linux)

В Windows для каждого устройства хранения создается отдельная файловая система, в Unix-системах всегда только одна файловая система, устройства хранения монтируются к разным точкам системы.

У скрытых файлов имя начинается с точки.

Утилита tree:
* ```tree```
* ```tree /path/to/folder```
* ```tree -dA /path/to/folder```
* ```tree -LhaC 3``` - показать структуру директории на 3 уровня вглубь

## Операции с файлами и каталогами
* ```touch``` - команда для установки времени последнего изменения файла
  * ```touch <имя_файла>``` - создает пустой файл и меняет время доступа к нему
* ```echo "some text" > <filename>``` - создаст текстовый файл с текстом "some text"
* ```file <file>``` - покажет тип файла
  * ```file *``` - покажет типы всех файлов в директории
* ```cp``` - копирование файлов и папок
  * ```cp <dir1> <dir2>``` - dir1 - откуда, dir2 - куда
  * ```cp -i <dir1> <dir2>``` - интерактивное копирование (предупредит, если файл будет перезаписан)
  * ```cp -r <dir1> <dir2>``` - скопировать директорию и все ее содержимое (рекурсивно)
  * ```cp -u <dir1> <dir2>``` - копировать только файлы, которых нет в каталоге
  * ```cp -v <dir1> <dir2>``` - выводить информацию в процессе копирования (verbose)
* ```mv``` - перенос/переименование файлов и папок
  * ```mv <file1> <file2>``` - переименует file1 в file2
  * ```mv <file> <dir>``` - перенесет file в dir
  * ```mv <dir1> <dir2>``` - переименует dir1 в dir2
  * Флаги те же, что и у mv
* ```rm``` - удаление файлов
  * ```rm <file>``` - удалит file
  * ```rm -r <dir>``` - удалит dir (рекурсивно)
  * ```rm -f <file>``` - удалит file (force)
* ```mkdir <dir>``` - создание директории
* ```rmdir <dir>``` - удаление директории

## Поиск файлов
* ```locate <строка>``` - вывод всех файлов, соответствующих строке
* ```find``` - поиск файлов в иерархии каталогов
  * ```find <dir>``` - вывести список всего содержимого директории и ее дочерних директорий рекурсивно
  * ```find folder1 -name "file1"``` - ищет в определенной директории и всех ее дочерних директориях файл или папку с именем file1
  * ```find -t d folder1 -name "dir1"``` - ищет папку dir1 в папке folder1
  * ```find -t f folder1 -name "file1"``` - ищет файл file1 в папке folder1
  * ```find folder1 -name "[a-c]*"``` - можно применять маски для поиска
  * ```find . -size +5M``` - поиск по размеру файла
  * ```find . -atime +5``` - поиск файлов, к которым последний раз обращались 5 (и более) дней назад
  * ```find . -ctime +5``` - поиск файлов, созданных 5 (и более) дней назад
  * ```find . -mtime +5``` - поиск файлов, измененных 5 (и более) дней назад
  * ```find ~/ -atime +100 -exec rm -i {} \``` - можно выполнять действия с найденными файлами

## Вывод содержимого файла
* ```cat <file>``` - вывод всего файла (объединения файлов)
  * ```cat -n <file>``` - пронумеровать строки в выводе
* ```less <file>``` - вывод содержимого файла
* ```head <file>``` - первые 10 строк файла
  * ```head -n 100 <file>``` - первые 100 строк файла
* ```tail <file>``` - последние 10 строк файла
  * ```tail -n 100 <file>``` - последние 100 строк файла
* ```wc file.txt``` - word count - подсчет числа строк, слов, байтов в файлах
  * ```wc -l file.txt``` - количество строк в файле

## Текстовые редакторы
| Тип                 | Категория  | Вход                 | Выход        |
|---------------------|------------|----------------------|--------------|
| Gedit (Text Editor) | Текстовый  | ```gedit file.txt``` |              |
| Vim                 | Текстовый  |                      | ```:q!```    |
| nano                | Текстовый  | ```nano file.txt```  | ```Ctrl+X``` |
| emacs               | Текстовый  |                      |              |

## Подстановки
grep - global regular expression print

```grep [параметры] регулярное_выражение [файл...]``` - поиск строк, соответствующих шаблону
* ```grep -i <шаблон> [файл...]``` - игнорировать регистр
* ```grep -v <шаблон> [файл...]``` - выводить строки, где совпадение с шаблоном НЕ найдено
* ```grep -c <шаблон> [файл...]``` - вывести число совпадений
* ```grep -n <шаблон> [файл...]``` - вывести номер строки с совпадением
* ```grep -E <шаблон> [файл...]``` - использовать сложное регулярное выражение в кавычках

Примеры:
* ```grep abc file.txt``` - вывести строки из файла, в которых есть подстрока abc
* ```grep -n abc file.txt``` - вывести строки из файла, в которых есть подстрока abc + номер строки
* ```grep ^abc file.txt``` - вывести строки из файла, которые начинаются с подстроки abc
* ```grep abc$ file.txt``` - вывести строки из файла, которые заканчиваются подстрокой abc
* ```grep -inr <string>``` - найти строку в любом файле этой директории или дочерних директорий
* ```grep -Е '^(abc|efg)' file.txt``` - вывести строки, которые начинаются с abc или с efg
* ```grep -Е '^([a-c]|[A-C])' file.txt``` - вывести строки, которые начинаются с abc или с ABC

**Wildcards** - шаблоны поиска
* ```*``` - астерикс соответствует любому количеству символов
  * ```ls *.json``` - найдет все файлы с расширением json
  * ```echo D*``` - Desktop, Documents
  * ```echo /usr/*/share```
* ```?``` - соответствует одному любому символу
  * ```ls ???.txt``` - найдет все файлы, в имени которых 3 символы
* ```[символы]``` - любой один символ из множества
  * ```[abc]*``` - все имена файлов, начинающиеся с 'a', 'b', 'c'
* ```[!символы]``` - любой один символ НЕ из множества
* ```[[:класс:]]``` - любой один символ, принадлежащий указанному классу
  * alnum - алфавитно-цифровые символы
  * alpha - алфавитные символы
  * digit - цифровые символы
  * lower - буквы в нижнем регистре
  * upper - буквы в верхнем регистре
* ```echo $((выражение))```
  * ```echo $((2 + 2))``` ==> 4
* ```echo {z..a}```
  * ```echo N_{1..3}``` ==> N_1, N_2, N_3
  * ```mkdir {2007..2009}-{01..12}```
* ```echo $USER``` - подстановка параметров
* ```echo $(ls)``` - подстановка команд
* ```echo \a``` - подстановка управляющей последовательности (звуковой сигнал)
* Экранирование символов:
  * ```echo \$5.00```
  * ```echo text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER```
    * text /home/me/ls-output.txt a b foo 4 me
  * ```echo "text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER"```
    * text ~/*.txt {a,b} foo 4 me
  * ```echo 'text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER'```
    * text ~/*.txt {a,b} $(echo foo) $((2+2)) $USER

## Потоки и конвейеры
Стандартные потоки данных
* stdin (ввод, дескриптор 0)
  * ```cat < file.txt```
* stdout (вывод, дескриптор 1)
  * ```>``` - стандартный вывод с перезаписью файла
  * ```>>``` - стандартный вывод с добавлением в конец файла
  * ```ls /path/to/folder > ls-output.txt```
  * ```cat log_*.txt > all_logs.txt```
* stderr (ошибки, дескриптор 2)
  * ```ls /path/to/folder 2> ls-output.txt```
  * ```ls /path/to/folder &> ls-output.txt``` - перенаправление и стандартного вывода, и потока ошибок
  * ```ls /path/to/folder 2> /dev/null```

Конвейер (piping) - pipe принимает stdout от команды слева от | и превращает его в stdin для команды справа.
* ```команда1 | команда2```
* ```ls /usr/bin | less```
* ```ls /usr/bin | grep zip``` - выведет список файлов из каталога /usr/bin, имя которых содержит подстроку zip
* ```ls /bin /usr/bin | sort | less``` - добавление фильтра
* ```ls /bin /usr/bin | sort | uniq | less``` - поиск повторяющихся строк в отсортированном файле
* ```ls /bin /usr/bin | sort | uniq | wc -l``` - количество строк
* ```ls /bin /usr/bin | sort | uniq | grep <шаблон>``` - найти все файлы, которые имеют в имени последовательность символов

Обработка стандартного вывода одного или нескольких файлов:
* ```sort``` - сортирует содержимое стандартного ввода одного или нескольких файлов, передает в стандартный вывод
  * ```sort file.txt``` - отсортировать файл
  * ```sort file1.txt file2.txt file3.txt > file.txt``` - соединение нескольких файлов в один отсортированный файл
* ```uniq``` - выявление и удаление повторяющихся строк (ввод должен быть отсортирован!)
  * ```sort file.txt | uniq```
  * -c - вывести список повторяющихся строк
  * -d - вывести только повторяющиеся строки
  * -u - вывести только уникальные строки
  * ```cat file.txt | xargs -n 1 | sort | uniq``` - посчитать количество уникальных слов в файле
* ```cut``` - удаление фрагментов из всех строк в файлах
  * ```cut -f 3 file.txt | cut -c 7-10``` - извлечь из файла третий столбец (столбцы разделены табуляцией), содержащий даты, и извлечь из них год
* ```paste``` - добавление столбцов в файлы
* ```join``` - объединение строк из двух файлов по общему полю
* ```comm file1.txt file2.txt``` - построчное сравнение двух сортированных файлов
* ```diff file1.txt file2.txt``` - построчное сравнение файлов
* ```tr``` - перекодирование или удаление символов
* ```sed``` - stream editor - потоковый редактор для фильтрации и преобразования текста
  * ```sed -e "s/oo/OO/g" file.txt``` - заменить все символы oo на OO
  * ```sed -e "s/oo/OO" file.txt``` - заменить только первое вхождение oo в каждой строке на OO
  * ```sed -e "s/[f|F]/_/g" file.txt``` - заменит все вхождения f или F на _ во всем файле
  * ```sed -e "y/abc/ABC/" file.txt``` - замена a, b, c на A, B, C соответственно
  * ```sed -i "s/{find}/{replace}/g" {file}``` - заменить строку в файле

## Управление процессами
Ядро хранит информацию обо всех процессах, чтобы упорядочить их работу.
Каждый процесс имеет Process ID - PID. Родительские процессы запускают дочерние процессы.
Ядро следит за памятью, выделенной каждому процессу, за готовностью процессов возобновлять выполнение.
Каждый процесс хранит идентификатор владельца и пользователя, действующий идентификатор пользователя и прочее.

В момент запуска системы ядро инициирует выполнение нескольких собственных задач в виде процессов и запускает программу с названием init (PID=1).
Init выполняет последовательность сценариев командной оболочки (/etc - init scripts), которые запускают все системные службы.

Демоны - программы, действующие в фоновом режиме.

* ```time <команда>``` - исполнить команду и составить статистику о том, сколько времени потрачено на исполнение
* ```echo $$``` - идентификатор текущего процесса
* ```ps``` - список процессов
  * ```ps``` - вывести список процессов, связанных с текущим сеансом
  * ```ps x``` - вывести список процессов, независимо от того, какие терминалы управляют ими
  * ```ps aux``` - процессы всех пользователей в системе с указанием идентификатора и пользователя от имени которого они запущены
* [Интерактивные просмотрщики процессов](https://wiki.dieg.info/top):
  * ```top``` - интерактивный просмотрщик процессов
    * Динамически выводит в режиме реального времени информации о работающей системе, т.е. о фактической активности процессов
    * По умолчанию выдает задачи, наиболее загружающие процессор сервера
    * ```top -u <username>``` - вывести только задачи данного пользователя
  * ```htop``` - аналог top
* ```job``` - список процессов фоновых в текущем шелле
* ```kill [-сигнал] PID``` - завершение процесса
  * ```kill -15 PID``` - мягкое завершение процесса
  * ```kill -9 PID``` - жесткое завершение процесса
* ```killall [-u пользователь] [-сигнал] имя...``` - останавливает несколько процессов
* ```lsof -i:5000``` - выведет все процессы, запущенные на порту 5000
* ```pstree``` - список процессов, отражающий видеосвязь "родитель-потомок"

Сигналы команды kill

| Номер | Имя   | Значение                   |
|-------|-------|----------------------------|
| 1     | HUP   | Обрыв связи                |
| 2     | INT   | Прервать (Interrupt)       |
| 3     | QUIT  | Выйти                      |
| 9     | KILL  | Уничтожить                 |
| 11    | SEGV  | Ошибка сегментации         |
| 15    | TERM  | Завершить                  |
| 18    | CONT  | Продолжить                 |
| 19    | STOP  | Приостановить              |
| 20    | TSTP  | Сигнал "Стоп" с клавиатуры |

## Управление процессами
* Прерывание (INT): ```Ctrl + C```
* Перевод процесса в фоновый режим:
  * ```<команда> &```
  * ```bg %1```
* Возврат процесса на передний план (1 - номер задания): ```fg %1```
* Приостановка процесса: ```Ctrl + Z```

## Файловые системы Linux
* Ext2
* Ext3
* Ext4
* Reiser FS
* Reiser 4
* SWAP

Иноды (inode - индексный дескриптор) - ключи файловой таблицы. Инод содержит в себе информацию о файле:
* Принадлежность владельцу (пользователь и группа)
* Режим доступа (чтение, запись, выполнение)
* Тип файла
* Размер
* Размещение на диске

Файловая система разделена на 2 части: блоки данных (содержимое файла) и иноды (имя файла).

Основная информация о файловой системе:
* ```free``` - объем памяти и ее использование
* ```df``` - disk free - объем свободного пространства на дисках
  * ```df -ih``` - количество инодов, доступных в файловой системе
* ```dh -h``` - информация о свободном и занятом месте
* ```du -ha``` - место, занятое директорией (все содержимое папок и подпапок)
  * ```du -h --max-depth=1 /var/``` - информация о потомках первого уровня
  * ```du -sh folder``` - размер только этой папки
* ```dmidecode``` - вывод информации об аппаратном обеспечении

## Ссылки на файлы
Ссылки бывают:
* Мягкие (символические)
  * ```ln -s data.txt data.txt_sym```
  * При создании символической ссылки, на самом деле, создается файл общего типа, содержащий текстовый указатель на файл или каталог
  * Подобие ярлыка в Windows
  * При удалении символической ссылки файл не удаляется
  * Когда файл удален, то ссылка становится "битой"
* Жесткие
  * ```ln data.txt data.txt_hard```
  * По умолчанию каждый файл имеет одну жесткую ссылку, определяющую его имя
  * Создавая жесткую ссылку, мы создаем дополнительную запись в каталоге для файла
  * Не можем указывать на файл в другом разделе диска
  * Жесткая ссылка неотличима от самого файла
  * Жесткая ссылка не может указывать на каталог
  * Файл не удаляется до тех пор, пока на него есть жесткие ссылки
  * При удалении жесткой ссылки файл не удаляется

## Создание архивов
* ```cpio``` - копирует файлы из и в архив
  * ```ls * | cpio -o > archive.cpio``` - создаст архив, содержащий все файлы текущей директории
  * ```find . -name * | cpio -o > archive.cpio``` - создаст архив, содержащий все файлы текущей директории и поддиректорий
  * ```cpio -id < archive.cpio``` - распакует файл, создав структуру папок
* ```dd```- создает точную копию файла бит в бит
* ```gzip``` - сжимает и распаковывает файлы
  * ```gzip file.txt```
* ```gunzip``` - разархивирует файлы
  * ```gunzip file.txt.gz``` - разархивирует файлы
  * ```gunzip -l file.txt.gz``` - покажет список файлов в архиве, степень сжатия и размер до и после сжатия
* ```tar``` - создает архив из файлов
  * ```tar -cf archive.tar foo bar``` - создаст архив из файлов foo и bar
  * ```tar -tvf test.tar``` - покажет все файлы в архиве
  * ```tar -xf archive.tar``` - распакует архив
  * ```tar -czf archive.tar.gz foo bar``` - создаст архив со сжатием gzip

## Обслуживание файловой системы
* ```fsck``` - проверяет файловую систему на целостность
* ```fdisk``` - команда для работы с разделами жестких дисков
  * ```fdisk -l``` - покажет все подключенные жесткие диски и разделы на них
* ```mkfs``` - форматирование жесткого диска
  * ```mkfs -t ext2/dev/sdb1``` - форматирование раздела в указанную файловую систему
  * ```mkfs -sL /dev/sdb1``` - узнать тип файловой системы
* ```mount``` - монтирование разделов
  * ```mount``` - покажет текущие подмонтированные разделы
  * ```mount -t ext3 /dev/sdb1 /mnt/folder``` - смонтирует sdb1 в папку folder
  * ```umount /dev/sdb1``` - отмонтировать раздел
  * ```/etc/fstab``` - файл содержит статическую информацию о том, какой раздел куда смонтировать при загрузке

## Установка и удаление программ
Способы установки ПО в Linux:
* Компиляция из исходного кода
* Установка из пакета
* Установка из репозитория

### Компиляция из исходного кода
Чтобы скомпелировать программу из исходного кода необходимо:
1. Установить компилятор (например, gcc для C)
   * ```which gcc```
2. Скачать исходный код программы
3. Распаковать архив с кодами
4. Сконфигурировать параметры компиляции скриптом configure
5. Выполнить компиляцию бинарных файлов утилитой make
6. Установить (разместить нужные файлы в нужных местах) командой make install

Пример:
```
cd /usr/local/src
wget http://www.php.net/distributions/php-5.5.8.tar.gz
tar zxvf php-5.5.8.tar.gz
cd /usr/local/src/php-5.5.8
./configure
make
make install
```

### Установка из пакетов
dpkg - утилита для установки пакетов в Debian
* ```dpkg -l``` - информация обо всех установленных пакетах
* ```dpkg -l firefox``` - информация об установленном пакете firefox
* ```dpkg -p firefox``` - подробная информация о пакете firefox
* ```dpkg -i quota.deb``` - установит пакет
* ```dpkg -r firefox``` - удалит пакет (пакет останется в базе как удаленный)
* ```dpkg -L firefox``` - покажет файлы, установленные пакетом
* ```dpkg -P firefox``` - удалит программу вместе с конфигурационными файлами
* ```dpkg -S file``` - покажет, к какому пакету принадлежит файл

### Установка из репозитория
* ```apt``` - Advanced Packaging Tool
* ```apt-get``` - управляет пакетами и репозиториями
  * ```apt-get install <package>``` - установит пакет со всеми зависимостями
  * ```apt-get remove <package>``` - удалит пакет, но не его зависимости
  * ```apt-get autoremove``` - удалит все ненужные пакеты
  * ```apt-get upgrade``` - обновит все пакеты в системе
  * ```apt-get dist-upgrade``` - обновит систему (может обновить дистрибутив на новую версию)
  * ```apt-get update``` - обновляет кеш файлов
* ```apt-cache``` - команда для работы с локальным кешем файлов
  * ```apt-cache search <package>``` - покажет описание пакета, если он установлен
  * ```apt-cache show <package>``` - покажет подробное описание пакета
  * ```apt-cache depends <package>``` - покажет зависимости пакета из локальной базы пакетов
  * ```apt-cache rdepends <package>``` - покажет, кто зависит от пакета
* ```aptitude``` - управление пакетами (объединяет функциональность apt-get и apt-cache)
  * ```aptitude install <package>``` - установит пакет
  * ```aptitude search <package>``` - ищет пакет по имени

## Компьютерные сети
* ```ping 8.8.8.8``` - проверка доступности удаленного хоста
* ```traceroute site.org``` - пошаговая трассировка маршрута до удаленного хоста
* ```hostname``` - hostname текущего компьютера
* ```ip``` или ```ifconfig``` или ```ipconfig``` - текущая настройка интерфейсов
* ```wget <link>``` - загрузить веб-страницу или веб-ресурс
* ```curl -X POST -d "{key: value}" <link>``` - отправить HTTP-запрос на веб-сервер
* ```route -n``` - текущие маршруты
  * ```route add``` - добавит статический маршрут
  * ```route del``` - удалит существующий маршрут
* ```netstat | head -n20``` - список открытых сокетов и связанной с ними информации
* ```nslookup <IP-адрес>``` - найти hostname для удаленного IP-адреса

Конфигурационные файлы:
* ```/etc/services``` - список портов с подписями
* ```/etc/hostname``` - имя машины
* ```/etc/hosts``` - статические записи ip - имя компьютера
* ```/etc/resolv.conf``` - адреса днс серверов
* ```/etc/nsswitch.conf``` - настройки поиска

## Работа с удаленной машиной
* ```ssh <remote>``` - подключение к удаленному узлу по его имени
  * ```exit``` - разрыв соединения
* ```scp <remote>:<path/to/file> <path/to/path>``` - secure copy
* ```sftp <remote>``` - safe ftp (File Transfer Protocol)
* ```rsync <параметры> <источник> <приемник>``` - синхронизирует локальные и удаленные каталоги

## Командные оболочки и скрипты
Переменные командной строки:
* Системные переменные
* Пользовательские переменные

```
# Переменная
var1

# Ссылка на переменную
$var1

var='12345' # Содержание всех переменных будут интерпретированы как строки 
echo var ==> var
echo $var ==> 12345

variable=$var
echo $variable ==> 12345
echo "$variable" ==> 12345
echo '$variable' ==> $variable

# Встроенные документы (here document)
# Формат:
# команда << индикатор
# текст
# индикатор
cat << _EOF_
Текст
Это
многострочный
текст
_EOF_
```

При присвоении переменной другой несуществующей переменной будет присвоено пустое значение.

* ```unset var``` - сброс значения переменной

### Скрипты
Shell-скрипт - текстовый файл с расширением .sh, в котором последовательно записаны команды.
У скрипта должны быть установлены права на выполнение (```chmod +x my_scr.sh```).

Скрипт начинается со строки, в которой указывается путь до интерпретатора, который будет этот скрипт обрабатывать:
* ```#!/bin/bash```
* ```#!/bin/sh```
* ```#!/usr/bin/php```
* ```#!``` - shebang

Пример скрипта hello.sh:
```
#!/bin/bash
# Это комментарий
STRING="Hello"
read ... ==> оператор ввода
echo $STRING ==> оператор вывода
exit ==> код завершения
```

Запуск скрипта:
* ```bash hello.sh```
* ```./hello.sh```
* ```hello``` - если скрипт лежит в одной и директорий, содержащихся в переменной $PATH

Переменной можно присваивать значение вывода какой-либо команды, используя: ```$(comand)```
```
where=$(pwd)
where2='pwd'
echo "$where" ==> /home/user
echo "$(pwd)" ==> /home/user
echo "$where2" ==> /home/user
```

## Соответствие консольных команд Windows и Linux
[Сответствие консольных команд Windows и Linux](https://white55.ru/cmd-sh.html)
