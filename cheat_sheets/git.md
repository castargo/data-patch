# GIT cheat sheets

[Git book](https://git-scm.com/book/ru/v2)

Команда Git:
```commandline
git <опции> <команда> <аргументы>
```

## Первоначальная настройка Git
Утилита git config позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. 
Эти параметры могут быть сохранены в трёх местах:
* Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев (параметр --system).
* Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя (параметр --global).
* Файл config в каталоге Git (.git/config) репозитория, используемый в данный момент, хранит настройки конкретного репозитория (параметр --local).

Посмотреть установленные настройки:    
* ```git config --list --show-origin```
* ```git config --list```
* ```git config user.name```

Настройки пользователя:         
* ```git config --global user.name "John Doe"```
* ```git config --global user.email johndoe@example.com```
* Текстовый редактор:
  * ```git config --global core.editor emacs```
  * ```git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"```
* ```git config --global init.defaultBranch main```

## Первичные настройки репозитория

Создать Git-репозиторий можно одним из двух способов:
* Сделать Git-репозиторий из локального каталога:
  * Пусть у нас есть какой-то проект в каталоге, тогда достаточно выполнить команду: ```git init```
  * Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория.

* Клонировать существующий Git-репозиторий
  * В Git реализовано несколько транспортных протоколов:
    * Клонирование по ssh:       
    ```git clone git@___.git```
    * Клонирование по http:       
    ```git clone git://___.git```
  * Результирующий каталог будет назван smth: ```git clone https://github.com/smth2 smth```

#### Дополнительные настройки
* Создать файл .gitignore
* Инициализировать git flow: ```git flow init```

## Работа с файлами

Определение состояния файлов:         
```git status```

Отслеживание новых файлов:       
```git add <новый файл>```

Просмотр индексированных и неиндексированных изменений:          
```git diff```

Просмотр индексированных и неиндексированных изменений, которые войдут в следующий коммит:          
```git diff --cached```

Коммит изменений:         
```git commit -m "Add some changes""```

Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый 
на момент коммита файл, позволяя вам обойтись без git add:       
```git commit -a -m "Add some changes""```

Удаление файлов из Git (удалить файл из последнего индекса):         
```git rm -f <файл>```       
```git rm --cached <файл>```       

Перемещение файлов (например, для переименования):          
```git mv file_from file_to```

Просмотр истории коммитов (git log):           
* По умолчанию перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке: ```git log```
* Разница (патч - patch), внесенный в каждый коммит + ограничение кол-ва записей в выводе команды: ```git log -p -2```
* Сокращенная статистика для каждого коммита: ```git log --stat```
* Изменение формата вывода (--pretty)
  * Опция oneline выводит каждый коммит в одну строку: ```git log --pretty=oneline```
  * Указание формата для вывода информации: ```git log --pretty=format:"%h - %an, %ar : %s"```
  * Список коммитов, сделанных за последние две недели: ```git log --since=2.weeks```

Изменение последнего коммита - для незначительных изменений (склеивание коммитов, изменение последнего сообщения коммита):        
```commandline
git add <недостающий файл> / или другое действие
git commit --amend
git push --force
```

Исключение файла из индекса:        
* ```git reset HEAD <file>```
* ```git restore --staged <file>```

Откат до определенного коммита:
```commandline
git log
git reset --soft / --hard <имя коммита>
git commit "..." / git add выполняется автоматически
git push --force
```

Откат изменений в файле (затрет изменения, без возможности восстановления):             
* ```git checkout -- <file>```
* ```git restore <file>```

Работа с удаленными репозиториями:         
* Просмотр удалённых репозиториев: ```git remote -v```
* Просмотр информации об удаленном репозитории: ```git remote show <remote>```
* Переименование удалённых репозиториев: ```git remote rename <старое имя> <новое имя>```
* Добавление удалённых репозиториев: ```git remote add <shortname> <url>```
* Удаление удалённых репозиториев: ```git remote remove <remote>```

Получение изменений из удаленного репозитория:       
* ```git fetch [remote-name]``` - связывается с указанным удалённым проектом и забирает те данные, которых локально ещё нет.
* ```git merge <название ветки>``` - слияние веток
* ```git pull``` - git pull = git fetch + git merge 

Отправка изменений в удаленный репозиторий:       
```git push <remote-name> <branch-name>```

Работа с тегами:       
* Просмотр списка тегов: ```git tag```
* Поиск тега по шаблону: ```git tag -l "v1.8.5*"```
* Создание тегов: Git использует 2 основных типа тегов (легковесные и аннотированные):
  * Легковесный тег - указатель на определённый коммит: ```git tag v1.4-lw```
  * Аннотированные теги (рекомендовано) хранятся в базе данных Git как полноценные объекты, они имеют контрольную сумму, 
  содержат имя автора, его e-mail и дату создания, имеют комментарий и могут быть подписаны и проверены с помощью GPG:
  ```git tag -a v1.4 -m "my version 1.4"```
* Просмотр тега: ```git show v1.4```
* Пометка тегом уже пройденные коммиты: ```git tag -a v1.2 9fceb02```
* Обмен тегами: 
  * ```git push origin <tagname>```
  * ```git push origin --tags```
* Удаление тегов: ```git tag -d v1.4-lw```, затем ```git push origin --delete <tagname>```
* Получение файлов, помеченных тегом: ```git checkout v2.0.0```

Псевдонимы (aliases) в Git - настройка shortcuts для команд:
* ```git config --global alias.ci commit``` - вместо ввода git commit достаточно набрать только git ci
* ```git config --global alias.unstage 'reset HEAD --'``` - эквивалентно:
  * ```git unstage fileA```
  * ```git reset HEAD -- fileA```
* ```git config --global alias.last 'log -1 HEAD'```

## Ветвление

Ветка в Git - это файл, состоящий из 40 символов контрольной суммы SHA-1 коммита, на который она указывает.
При выполнении операции коммита, Git сохраняет коммит в виде объекта, который содержит указатель на снимок (snapshot) 
подготовленных данных, имя автора и email, сообщение и указатель на коммит или коммиты-родители.

Во время индексации Git вычисляет контрольную сумму каждого файла (SHA-1), 
затем каждый файл (блоб - большой бинарный объект) сохраняется в репозиторий , а контрольная сумма попадёт в индекс.

Просмотр информации о ветках:
* Cписок имеющихся веток: ```git branch```
* Cписок имеющихся веток (в том числе и удаленных): ```git branch --all```
* Просмотр последнего коммита на каждой из веток: ```git branch -v```
* Ветки, уже слитые с текущей: ```git branch --merged```
* Ветки, еще не слитые с текущей: ```git branch --no-merged```

Создание новой ветки (без переключения на нее):       
```git branch <branchname>```

Переключение веток:      
```git checkout <branchname>```

Создание новой ветки и переключение на нее:       
* ```git checkout -b <newbranchname>``` - soft delete
* ```git checkout -D <newbranchname>``` - hard delete

Просмотр информации об истории коммитов, текущего положения указателей веток и истории ветвления:       
```git log --oneline --decorate --graph --all```

Удаление ветки (локально):          
```git branch -d <newbranchname>```

Слияние веток:        
```git merge <newbranchname>```

Виды слияния в Git: 
* Перемотка (fast-forward merge) - перемещение указателя ветки вперед (коммит был прямым потомком)
* «Истинное» или трёхстороннее слияние (true merge) - коммит не является прямым родителем ветки, с которой мы выполняем слияние.
  Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый результирующий снимок трёхстороннего слияния, 
  а затем автоматически делает коммит.

Разрешение конфликтов слияния:       
1. Конфликт возникает тогда, когда была изменена одна и та же часть файла по-разному в двух объединяемых ветках.
2. Всё, где есть неразрешённые конфликты слияния, перечисляется как неслитое. Git добавляет в конфликтующие файлы специальные маркеры конфликтов.
3. Разрешив каждый конфликт во всех файлах, запустите git add для каждого файла, чтобы отметить конфликт как решённый.
4. Добавление файла в индекс означает для Git, что все конфликты в нём исправлены.
5. Графический инструмент для разрешения конфликтов: git mergetool

Локальное переименование веток:      
```git branch --move <old-branch-name> <new-branch-name>```

Отправка исправленной ветки в удаленный репозиторий:         
```git push --set-upstream origin <new-branch-name>```

Удаление старой ветки:         
```git push origin --delete <old-branch-name>```

## Документация 
* ```git help <команда>```
* ```git <команда> --help```
* ```man git-<команда>```
* ```git help config```
