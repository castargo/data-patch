# GIT cheat sheets

[Git book](https://git-scm.com/book/ru/v2)

Команда Git:
```
git <опции> <команда> <аргументы>
```

Документация:
* ```git help <команда>```
* ```git <команда> --help```
* ```man git-<команда>```
* ```git help config```

Git хранит данные как снимки (snapshot) во времени. 

<p align="center">
  <img width="400" height="200" src="pictures/git1.png"/>
</p>

## Первоначальная настройка Git
Утилита git config позволяет просматривать и настраивать параметры, контролирующие все аспекты работы Git, а также его внешний вид. 
Эти параметры могут быть сохранены в трёх местах:
* Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их репозиториев (параметр --system).
* Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя (параметр --global).
* Файл config в каталоге Git (.git/config) репозитория, используемый в данный момент, хранит настройки конкретного репозитория (параметр --local).

Посмотреть установленные настройки:    
* ```git config --list --show-origin```
* ```git config --list```
* ```git config user.name```

Настройки пользователя:         
* ```git config --global user.name "John Doe"```
* ```git config --global user.email johndoe@example.com```
* ```git config --global core.editor emacs```
* Текстовый редактор:
  * ```git config --global core.editor emacs```
  * ```git config --global core.editor "'C:/Program Files/Notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin"```
* ```git config --global init.defaultBranch main```
* ```git config --global credential.helper cache```

## Первичные настройки репозитория
Создать Git-репозиторий можно одним из двух способов:
* Сделать Git-репозиторий из локального каталога:
  * Пусть у нас есть какой-то проект в каталоге, тогда достаточно выполнить команду: ```git init```
  * Эта команда создаёт в текущем каталоге новый подкаталог с именем .git, содержащий все необходимые файлы репозитория.

* Клонировать существующий Git-репозиторий с удаленного сервера:
  * В Git реализовано несколько транспортных протоколов:
    * Клонирование по ssh:       
    ```git clone git@___.git```
    * Клонирование по http:       
    ```git clone git://___.git```
  * Результирующий каталог будет назван smth: ```git clone https://github.com/smth2 smth```

Наиболее интересен вариант работы с удаленным сервером, так как в этом случае разработчик может делиться своими наработками с другими.
В момент клонирования Git заберет с удаленного сервера все удаленные ссылки - указатели в удалённых репозиториях, включая ветки, теги и так далее.
При клонировании командой ```git clone <repo>``` удаленный сервер будет по умолчанию назван «origin», будет создана ветка master, содержащая
все соответствующие удаленные ссылки, будет создана локальная ветка слежения origin/master.

Полный список удалённых ссылок можно получить с помощью команды ```git ls-remote <remote>```. 

При выполнении команды ```git clone -o booyah``` ветка слежения будет иметь вид booyah/master.

#### Дополнительные настройки
* Создать файл .gitignore
* Инициализировать git flow: ```git flow init```

## Коммиты (локально и удаленно)
* HEAD - указатель на последний коммит, сделанный в этой ветке (снимок последнего коммита). HEAD будет родителем следующего созданного коммита.
  * HEAD~ - родитель HEAD
* Индекс - следующий намеченный коммит или его снимок («область подготовленных изменений») - то, что Git просматривает, когда вы выполняете git commit.
* HEAD и индекс фиксируются в файлах, находящихся внутри каталога .git.

Определение состояния файлов:         
```git status```

Отслеживание новых файлов:       
* ```git add <новый файл>```
* ```git add --patch <новый файл>``` - частичное добавление файла в индекс

Коммит изменений:         
```git commit -m "Add some changes""```

Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже отслеживаемый 
на момент коммита файл, позволяя вам обойтись без git add:       
```git commit -a -m "Add some changes""```

Удаление файлов из Git (удалить файл из последнего индекса):         
* ```git rm -f <файл>```
* ```git rm --cached <файл>```

Перемещение файлов (например, для переименования):          
```git mv file_from file_to```

Изменение последнего коммита - для незначительных изменений 
(склеивание коммитов, изменение последнего сообщения коммита):        
```
git add <недостающий файл> / или другое действие
git commit --amend
# git commit --amend --no-edit - чтобы не изменять сообщение последнего коммита
git push --force
```

Удаление файла из каждого коммита:               
```git filter-branch --tree-filter 'rm -f passwords.txt' HEAD```

Исключение файла из индекса:        
* ```git reset HEAD <file>```
* ```git restore --staged <file>```

Построчная отмена изменений в файле (без возможности восстановления):
* ```git restore -p <file>```
  * [Статья Using Git restore to discard changes within a file](https://www.tempertemper.net/blog/using-git-restore-to-discard-changes-within-a-file)
  * s - split the current hunk into smaller hunkse - manually edit the current hunk
  * y - discard this hunk from worktree
  * n - do not discard this hunk from worktree 
  * ? - print help

Отмена индексации файла:        
```git reset file.txt```

Объединение двух коммитов в один:
```
git reset --soft HEAD~2
git commit...
```

Откат до определенного коммита:
```
git log

# Отмена команды git commit
git reset --soft <имя коммита>

# Отмена команды git commit + git add
git reset [--mixed] <имя коммита>

# Сброс рабочего каталога (с удалением из reflog)
git reset --hard <имя коммита>

git commit "..." / git add выполняется автоматически
git push --force
```

Сброс ветки до состояния удаленного репозитория:
```
git fetch --all
git reset --hard origin/master
```

Откат изменений в файле (затрет изменения, без возможности восстановления):             
* ```git checkout -- <file>```
* ```git restore <file>```

Работа с удаленными репозиториями:         
* Просмотр удалённых репозиториев: ```git remote -v```
* Просмотр информации об удаленном репозитории: ```git remote show <remote>```
* Переименование удалённых репозиториев: ```git remote rename <старое имя> <новое имя>```
* Добавление удалённых репозиториев: ```git remote add <shortname> <url>```
* Удаление удалённых репозиториев: ```git remote remove <remote>```

Получение изменений из удаленного репозитория:       
* ```git fetch [remote-name]``` - связывается с указанным удалённым проектом и забирает те данные, которых локально ещё нет.
* ```git merge <название ветки>``` - слияние веток
* ```git pull``` - git pull = git fetch + git merge 

Отправка изменений в удаленный репозиторий:       
```git push <remote-name> <branch-name>```

## Ветвление
Ветка в Git - это файл, состоящий из 40 символов контрольной суммы SHA-1 коммита, на который она указывает.
При выполнении операции коммита, Git сохраняет коммит в виде объекта, который содержит указатель на снимок (snapshot) 
подготовленных данных, имя автора и email, сообщение и указатель на коммит или коммиты-родители.

Во время индексации Git вычисляет контрольную сумму каждого файла (SHA-1), 
затем каждый файл (блоб - большой бинарный объект) сохраняется в репозиторий, а контрольная сумма попадёт в индекс.

Ветки бывают:
* Локальные
* Удаленные
* Ветки слежения: ```<remote>/<branch>``` (например, ветка master на сервере origin - ветка origin/master)
  * Ветка слежения - локальная ветка, полученная из удаленной ветки;
  * «Upstream branch» - ветка, за которой следит локальная ветка

Ветки слежения — это ссылки на определённое состояние удалённых веток; локальные ветки, которые нельзя перемещать, так как Git перемещает их автоматически 
при любой коммуникации с удаленным репозиторием, чтобы гарантировать точное соответствие с ним.

Просмотр информации о ветках:
* Cписок имеющихся веток: ```git branch```
* Cписок имеющихся веток (в том числе и удаленных): ```git branch --all```
* Просмотр последнего коммита на каждой из веток: ```git branch -v```
* Ветки, уже слитые с текущей: ```git branch --merged```
* Ветки, еще не слитые с текущей: ```git branch --no-merged```
* Просмотр веток слежения: ```git branch -vv```

Получение данных со всех удалённых серверов и просмотр веток слежения:            
```git fetch --all; git branch -vv```

Посмотреть удаленные ветки и дополнительную информацию про них:             
```git remote show <remote>```

Создание новой локальной ветки (без переключения на нее):       
```git branch <branchname>```

Переключение веток:      
```git checkout <branchname>```

Создание локальной ветки на основе ветки слежения (локальная ветка будет начинаться там же, где и <remote>/<branch>):                           
* ```git checkout -b <branch> <remote>/<branch>```          
* ```git checkout --track <remote>/<branch>```
* ```git checkout <branchname>``` - автоматическое создание ветки слежения при условии, что branchname еще не существует локально, 
   и существует только одна удалённая ветка с точно таким же именем.
* ```git branch -u <remote>/<branch>``` - настройка отслеживания локальной веткой удаленной ветки (-u или --set-upstream-to)

Создание новой ветки и переключение на нее:                           
```git checkout -b <newbranchname>```

Просмотр информации об истории коммитов, текущего положения указателей веток и истории ветвления:       
```git log --oneline --decorate --graph --all```

Удаление ветки (локально):          
* ```git branch -d <newbranchname>``` - soft delete
* ```git branch -D <newbranchname>``` - hard delete

Синхронизация изменений с удаленным сервером:          
```git fetch <remote>```                      
Примечание: эта команда определяет какому серверу соответствует, например, «origin», извлекает оттуда данные, которых еще нет локально, 
и обновляет локальную базу данных, сдвигая указатель origin/master на новую позицию.

Получение данных с удаленного сервера:            
```git pull```          
Примечание: git pull = git fetch + git merge
Примечание 2: если, находясь на ветке слежения, выполнить git pull, то Git уже будет знать с какого сервера получать данные 
и какую ветку использовать для слияния.

Отправка изменений на удаленный сервер:              
```git push <remote> <branch>```

Удаление веток на удалённом сервере:
```git push origin --delete <old-branch-name>```             
Примечание: сервер Git хранит данные пока не запустится сборщик мусора, поэтому если ветка была удалена случайно, чаще всего её легко восстановить.

Переименование веток:      
* Локальное переименование: ```git branch --move <old-branch-name> <new-branch-name>```
* Отправка исправленной ветки в удаленный репозиторий: ```git push --set-upstream origin <new-branch-name>```
* Удаление старой ветки: ```git push origin --delete <old-branch-name>```

Припрятывание изменений:
* ```git stash``` - сохранение измененных отслеживаемых файлов и проиндексированных изменений в хранилище
* ```git stash -u``` - припрятать также неотслеживаемые файлы
* ```git stash -a``` - припрятать еще и игнорируемые файлы
* ```git stash list``` - список припрятанных изменений
* ```git stash apply``` - применить последнее припрятанное изменение
* ```git stash apply stash@{2}``` - применить предыдущее припрятанное изменение
* Изменения могут быть припрятаны в одной ветке и восстановлены в другой
* ```git stash drop``` - удалить припрятанные изменения из хранилища
* ```git stash pop``` - применить припрятанные изменения и удалить их из хранилища
* ```git stash branch``` - создаст новую ветку с припрятанными изменениями

Очистка рабочего каталога:
* ```git clean``` - удаления неотслеживаемых файлов из рабочего каталога
* ```git clean -f -d``` - удаление всех неотслеживаемых файлов
* ```git clean -d -n``` - «имитируй работу команды и скажи мне, что ты будешь удалять»

## Способы внесения изменений из одной ветки в другую:
* Слияние: ```git merge <newbranchname>```
* Перебазирование: ```git rebase <newbranchname>```

### Слияние (merge)
Виды слияния в Git: 
* Перемотка (fast-forward merge) - перемещение указателя ветки вперед (коммит был прямым потомком)
* «Истинное» или трёхстороннее слияние (true merge) - коммит не является прямым родителем ветки, с которой мы выполняем слияние.
  Вместо того, чтобы просто передвинуть указатель ветки вперёд, Git создаёт новый результирующий снимок трёхстороннего слияния, 
  а затем автоматически делает коммит.

Продвинутое слияние:
* ```git merge --squash <branch>``` - создать новый коммит в текущей ветке (без коммита слияния)
* ```git merge --no-commit <branch>``` - не создавать ковый коммит автоматически
* ```git merge --abort``` - отмена слияния
* Указание версии слияния:
  * ```git merge -X theirs <branch>```
  * ```git merge -X ours <branch>```
  * ```git diff --ours / --theirs / --base```

Разрешение конфликтов слияния:       
1. Конфликт возникает тогда, когда была изменена одна и та же часть файла по-разному в двух объединяемых ветках.
2. Всё, где есть неразрешённые конфликты слияния, перечисляется как неслитое. Git добавляет в конфликтующие файлы специальные маркеры конфликтов.
3. Разрешив каждый конфликт во всех файлах, запустите git add для каждого файла, чтобы отметить конфликт как решённый.
4. Добавление файла в индекс означает для Git, что все конфликты в нём исправлены.
5. Графический инструмент для разрешения конфликтов: git mergetool

### Перебазирование (rebase)
https://git-rebase.io/

С помощью команды rebase можно взять все коммиты из одной ветки и в том же порядке применить их к другой ветке.            
Это работает следующим образом: берётся общий родительский снимок двух веток (текущей, и той, поверх которой вы выполняете перебазирование), 
определяется дельта каждого коммита текущей ветки и сохраняется во временный файл, текущая ветка устанавливается на последний коммит ветки, 
поверх которой вы выполняете перебазирование, а затем по очереди применяются дельты из временных файлов.

Перебазирование делает историю коммитов чище. История перебазированной ветки выглядит линейной.

Перебазирование повторяет изменения из одной ветки поверх другой в том порядке, в котором эти изменения были сделаны, 
в то время как слияние берет две конечные точки и сливает их вместе.

Интересные слияния:        
```git rebase --onto master <branch1> <branch2>``` - переключись на ветку 2, найди изменения относительно ветки 1 и примени их для ветки master.        
Затем:                    
```git checkout master```          
```git merge client```

**ВАЖНО: нельзя перемещать коммиты, уже отправленные в публичный репозиторий!!!**           
Когда вы что-то перемещаете, вы отменяете существующие коммиты и создаёте новые, похожие на старые, но являющиеся другими. 
Если вы куда-нибудь отправляете свои коммиты и другие люди забирают их себе и в дальнейшем основывают на них свою работу, 
а затем вы переделываете эти коммиты командой git rebase и выкладываете их снова, 
то ваши коллеги будут вынуждены заново выполнять слияние для своих наработок.

#### Другие способы внесения исправлений
Git rebase - команда, которая рассматривает патчи с точки зрения вносимых измененй. Кроме этой команды также существуют:
* ```git cherry-pick <commit>```                       
  * Берет изменения, вносимые одним коммитом, и пытается повторно применить их в виде нового коммита в текущей ветке.
    Полезно, когда нужно забрать несколько коммитов из другой ветки, а не сливать ветку целиком со всеми внесенными в нее изменениями.        
  * git rebase = git cherry-pick для цепочки коммитов  
* git revert
  * Она создаёт новый коммит, который вносит изменения, противоположные указанному коммиту, по существу отменяя его.
  * Полная противоположность git cherry-pick
* git rerere
  * Reuse recorded resolution (повторно использовать сохранённое решение)
  * Cпособ сокращения количества операций ручного разрешения конфликтов
  * Необходима, если часто проводятся команды перебазирования и слияния или есть необходимость поддерживать долгоживущие ветки

## Просмотр истории изменений
Просмотр изменений:
* ```git blame``` - позволяет посмотреть когда и кем редактировалась каждая строка файла в последний раз
* ```git diff``` - Просмотр индексированных и неиндексированных изменений
* ```git diff master``` - Просмотр полной разницы изменений, которые произойдут при слиянии веток
* ```git diff --cached``` - Просмотр индексированных и неиндексированных изменений, которые войдут в следующий коммит
* ```git diff --check``` - Просмотр списка ненужных пробелов

Изменения ветки, которые предстоит слить в основную ветку (сравнение последнего коммита ветки с первым общим родителем для обоих веток):
* Явное указание коммита:
  ```
  git merge-base contrib master
  git diff <commit>
  ```
* Краткая версия: ```git diff $(git merge-base contrib master)```
* Синтаксис троеточия: ```git diff master...contrib```

Просмотр истории коммитов (git log):           
* По умолчанию перечисляет коммиты, сделанные в репозитории в обратном к хронологическому порядке: ```git log```
* Просмотр коммитов текущей ветки, которые еще не включены в другую ветку: ```git log contrib --not master```
* Разница (патч - patch), внесенный в каждый коммит + ограничение кол-ва записей в выводе команды: ```git log -p -2```
* Сокращенная статистика для каждого коммита: ```git log --stat```
* Просмотр сообщений для каждого коммита: ```git log --no-merges```
* Изменение формата вывода (--pretty)
  * Опция oneline выводит каждый коммит в одну строку: ```git log --pretty=oneline```
  * Указание формата для вывода информации: ```git log --pretty=format:"%h - %an, %ar : %s"```
  * Список коммитов, сделанных за последние две недели: ```git log --since=2.weeks```
  * Выведет информацию с сокращенным SHA-1: ```git log --abbrev-commit --pretty=oneline```
* Просмотр родословной коммитов:
  * Вся родословная: ```git log --pretty=format:'%h %s' --graph```
  * Просмотр предыдущего коммита: ```git show HEAD^```
  * Показать родителя коммита: ```git show d921970^```
  * Показать второго родителя коммита: ```git show d921970^2```
  * HEAD~ и HEAD^ эквивалентны: ```git show HEAD~3``` или ```git show HEAD~~~```
* Просмотр диапазона коммитов
  * Две точки
    * Все коммиты, которые доступны из ветки experiment, но не доступны из ветки master: ```git log master..experiment```
    * Просмотр того, что будет отправлено в удалённый репозиторий: ```git log origin/master..HEAD```
  * Множественная выборка
    * Увидеть все коммиты, доступные из refA и refB, но не доступные из refC:
      * ```git log refA refB ^refC```
      * ```git log refA refB --not refC```
  * Три точки
    * Все коммиты, доступные хотя бы из одной ссылки, но не из обеих сразу
    * Коммиты доступные либо в ветке master, либо в experiment, но не в обеих сразу: ```git log --left-right master...experiment```

Просмотр журнала ссылок (RefLog - история командной строки):
* ```git reflog```
* ```git log -g master```

Поиск в истории коммитов или в рабочем каталоге по строке или регулярному выражению:          
```git grep```

## Теги
Работа с тегами:       
* Просмотр списка тегов: ```git tag```
* Поиск тега по шаблону: ```git tag -l "v1.8.5*"```
* Создание тегов: Git использует 2 основных типа тегов (легковесные и аннотированные):
  * Легковесный тег - указатель на определённый коммит: ```git tag v1.4-lw```
  * Аннотированные теги (рекомендовано) хранятся в базе данных Git как полноценные объекты, они имеют контрольную сумму, 
  содержат имя автора, его e-mail и дату создания, имеют комментарий и могут быть подписаны и проверены с помощью GPG:
  ```git tag -a v1.4 -m "my version 1.4"```
* Просмотр тега: ```git show v1.4```
* Пометка тегом уже пройденные коммиты: ```git tag -a v1.2 9fceb02```
* Обмен тегами: 
  * ```git push origin <tagname>```
  * ```git push origin --tags```
* Удаление тегов: ```git tag -d v1.4-lw```, затем ```git push origin --delete <tagname>```
* Получение файлов, помеченных тегом: ```git checkout v2.0.0```

## Псевдонимы (aliases)
Псевдонимы (aliases) в Git - настройка shortcuts для команд:
* ```git config --global alias.ci commit``` - вместо ввода git commit достаточно набрать только git ci
* ```git config --global alias.unstage 'reset HEAD --'``` - эквивалентно:
  * ```git unstage fileA```
  * ```git reset HEAD -- fileA```
* ```git config --global alias.last 'log -1 HEAD'```

## Сабмодули
* Разработка:
  * ```git submodule add https://github.com/chaconinc/DbConnector``` - добавление сабмодуля
  * ```git config -f .gitmodules submodule.DbConnector.branch stable``` - настройка ветки сабмодуля
  * Файл .gitmodules:
```
[submodule "DbConnector"]
	path = DbConnector
	url = https://github.com/chaconinc/DbConnector
```
* Клонирование проекта с подмодулями
  * ```git submodule init``` - инициализация локального конфигурационного файла
  * ```git submodule update --init --remote --recursive``` - получения всех данных проекта, извлечения соответствующего коммита, указанного в основном проекте
  * ```git clone --recurse-submodules https://github.com/chaconinc/MainProject``` - инициализация сабмодулей при инициализации проекта
* Полезные команды для работы с сабмодулями
  * ```git submodule foreach 'git stash'``` - припрятать все наработки во всех сабмодулях
  * ```git submodule foreach 'git checkout -b featureA'``` - создать новую ветку и переключиться на неё во всех подмодулях

## Выбор Workflow
* GitHubFlow
  * master
  * feature
* GitLabFlow
  * master
  * production
  * pre-production
  * stable (with cherry-pick)
  * feature
* GitFlow
  * master
  * develop
  * feature
  * release
  * hotfix

### GitFlow
Работа с GitFlow:
* ```git flow init``` - инициализация всех пяти веток
* ```git flow feature start myfeature``` - начало жизни фичи-ветки
* ```git flow feature finish myfeature``` - завершение жизни фичи-ветки (слияние myfeature с develop, удаление myfeature, переключение на develop)
* ```git flow feature publish myfeature``` - публикация фичи
* ```git flow feature pull origin myfeature``` - получение фичи
* ```git flow release start myrelease [BASE]``` - начало жизни релиза
* ```git flow release publish myrelease```
* ```git flow hotfix start version [BASENAME]```

<p align="center">
  <img src="pictures/gitflow.png"/>
</p>

## Форк публичного проекта
При форке нет доступа обновлять ветки проекта напрямую. Проект клонируется как обычно, в нем создаются тематические ветки, делаются коммиты и т. д.
Когда же работа в тематической ветке завершена и появляется необходимость передать изменения исходному проекту, 
необходимо перейти на страницу исходного проекта и нажать кнопку «Fork», тем самым создавая доступный для записи форк проекта. 
Затем нужно добавить URL на созданный проект ```git remote add myfork <url>```, а затем отправить изменения из тематической ветки.

Отправить изменения можно командой: ```git push -u myfork featureA```

Запрос на слияние: ```git request-pull origin/master myfork```

## Настройка удаленного репозитория
* Выбор протокола для связи с сервером:
  * Локальный протокол 
    * Удалённый репозиторий — другой каталог на диске.
    * Используется, если все члены команды имеют доступ к общей файловой системе, например к NFS.
    * ```git clone file:///srv/git/project.git```
    * ```git remote add local_proj /srv/git/project.git```
  * HTTP
    * Необходима аутентификация пользователя по логину и паролю.
  * Secure Shell (SSH)
  * Git-протокол
    * Специальный демон, который слушает порт 9418 и предоставляет сервис.
    * Отсутствует аутентификация.
    * Необходимо создать файл git-export-daemon-ok.
* Настройка Git-сервера или выбор готового хостинга
  * Гостевые Git-хостинги:
    * GitHub
    * GitLab: пользователи = учетные записи, проекты = git-репозитории, поддержка хуков
    * Bitbucket
    * Codebase
* Настройка базовых конфигураций
  * Генерация ssh-ключа

## Послесловие
<p align="center">
  <img height="400" src="pictures/git2.jpg"/>
</p>
