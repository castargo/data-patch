# System design

## Материалы
* [System Design от KARPOV.COURSES](https://karpov.courses/systemdesign)
* [ML for Developers: Design, Develop, Deploy, Iterate](https://github.com/GokuMohandas/Made-With-ML)
* Мифический человеко-месяц - Фредерик Брукс
* Высоконагруженные приложения. Программирование, масштабирование, поддержка - Клеппман Мартин
* Предметно-ориентированное проектирование (DDD): структуризация сложных программных систем - Эрик Эванс

## Принципы проектирования сервисов

0. Проговариваем ВСЕ детали, которые только возможно проговорить (explicit/implicit)
1. Фиксируем все проговоренное: Design doc, контракты взаимодействия сервисов и т.д.
2. Проверяем, что в команде есть необходимые компетенции
3. Оцениваем время реализации сервиса
    * По Бруксу:
        * Планирование - 30%
        * Написание кода - 20%
        * Программное тестирование - 25%
        * Системное тестирование - 25%

## План проектирования сервиса

### **1. Системный анализ: пишем Design doc**

* Требования к сервису формулируются в открытой форме, необходимо:
    * Приоритезировать функционал
    * Ограничить функционал
    * Зафиксировать функционал
* Design doc должен фиксировать:
    * Функциональные требования: что сервис умеет, как с ним будет взаимодействовать пользователь
    * Нефункциональные требования:   
        * Отзывчивость или Latency (задержка < 200 мс)
        * Надежность (uptime 99.9%)
        * Масштабируемость (поддержка 1 млн пользователей)
        * Безопасность (шифрование данных)
    * Ограничения: законодательные нормы
     
### **2. Оцениваем масштаб сервиса (нагрузка + бюджет)**

* Пользователи: Сколько активных пользователей в день/месяц?
    * [MAU, WAU, DAU](https://yandex.ru/adv/edu/materials/metriki-mau-wau-dau)
    * Для внутреннего пользования компании или для внешнего клиента?
    * У сервиса есть аналоги? Анализ конкурентов.
* Трафик: Сколько запросов в секунду?
    * RPS (requests per second)
        * RPS разных операций разный: считать данные легче, чем записать и т.п.
        * На старте можно ориентироваться на бенчмарки
        * Затем - нагрузочное тестирование
    * [Как оценить ёмкость сервиса и не упасть под нагрузкой](https://habr.com/ru/companies/yandex/articles/481134/)
* Дисковое пространство: объем хранимых данных (например, 10 ТБ в год) 
    * Сколько средний пользователь генерирует контента в день
    * Потенциальный прирост на горизонте месяца, года, пяти лет 
    * Дампы системы
* Сетевая нагрузка
    * Трафик за единицу времени и число соединений в единицу времени (10К-100К соединений)
    * Ограничения по трафику (облако, витая пара, оптоволокно, Infiniband)
    * Стоимость трафика
    * Приковые нагрузки, например, Black Friday для интернет-магазина

### **3. High-Level Design**

* Этап проектирования, при котором мы описываем, что делает сервис, какие в нем есть компоненты
* MVP-style
    * Фронтенд
    * Бэкенд
    * ML-сервис: контейнер с моделью, эмбеддер, реранкер
    * Хранилище: база данных, metadata-storage, файловое хранилище
* Что НЕ учитываем:
    * Специфику технологий
    * Нагрузку на систему
    * Масштабирование системы
* Оцениваем, какая команда нужна для проекта: состав, компетенции
* Тип архитектуры:  
    * Монолит vs микросервисы
    * Serverless (AWS Lambda) vs контейнеры (Kubernetes)
* Пользовательские сценарии
* Схема взаимодействия:  
    * Клиент-сервер, peer-to-peer, event-driven   
    
### **4. Low-Level Design**

* Разбиваем сервис на модули, взаимодействующие друг с другом
    * Например, теперь бэкенд - это аутентификация, кэш, API и т.д.
    * Модули общаются друг с другом, создают нагрузку в сервисе
* Общеупотребительные компоненты
    * Базы данных (смотри раздел 5)
    * Кэширование: Redis или Memcached для снижения нагрузки на БД
    * Балансировка нагрузки: Nginx, HAProxy
    * Брокеры сообщений: Kafka, RabbitMQ для асинхронной обработки (+Zookeeper)
        * Producers - сервисы, которые отправляют сообщения брокеру
        * Broker - очередь сообщений
        * Consumer - сервис(ы), которые считывают и обрабатывают сообщения из очереди
        * Сервисы можно шасштабировать за счет увеличения числа воркеров
    * CDN: Для статического контента (изображения, видео)
* Взаимодействия подсервисов
    * Stateless vs Stateful
        * Stateful (сокеты - долгоживущие соединения, сохраняют состояние сессии: чаты, стриминг, онлайн-игры)
        * Stateless (HTTP/REST - каждый запрос независим и не требует сохранения состояния сервером; лучше подходят для масштабируемости, микросервисов или сценариев с непостоянным трафиком)
    * Синхронная vs Асинхронная коммуникация
        * Синхронный обмен данными (например, клиент ожидает ответа)  
        * Асинхронная коммуникация через очереди сообщений (Celery, Kafka, RabbitMQ) или event-driven архитектуру, где компоненты реагируют на события без прямого взаимодействия
    * Двусторонняя vs Однонаправленная связь
        * Сокеты поддерживают двусторонний обмен данными (клиент и сервер могут отправлять данные в любое время)
        * Однонаправленные протоколы, например:  
            * HTTP/HTTPS (запрос → ответ, инициатива всегда на клиенте)
            * gRPC Streaming (однонаправленные потоки данных)
    * Обновление данных при изменении
        * AJAX Polling
        * HTTP Long-Polling

### **5. Работа с данными**

* [Виды СУБД](https://habr.com/ru/companies/amvera/articles/754702/):
    * Реляционные
        * Реляционная база данных — это тип базы данных, в которой данные организованы в таблицы, и эти таблицы связаны на основе данных, общих для каждой из них.
        * Примеры: SQLite, Postgres, MySQL
        * [ACID-требования](https://ru.wikipedia.org/wiki/ACID): Atomicity, Consistency, Isolation, Durability
        * 12 правил Кодда
    * Колоночные
        * Колоночная база данных — это такой тип базы данных, в которой данные группируются (хранятся и извлекаются) не по строкам, а по столбцам.
        * Из них быстро читать данные, но долго записывать
        * Примеры: ClickHouse, Hbase, Vertica, Cassandra
        * Data warehouses
    * Key-Value
        * Предназначен для осуществления быстрых, почти мгновенных запросов для таких задач как пользовательские сессии, кэш, отображение баланса, корзины интернет-магазина и т.д.
        * Примеры: Redis, Memcache
    * Документо-ориентированные
        * Хранение и запрос данных в виде документов (например JSON)
        * Хорошо подходит для хранения сущностей, например, профилей пользователей, каталогов, видео
        * Примеры: MongoDB, CouchDB, Amazon DocumentDB
    * Векторные
        * Примеры: Faiss, Chroma, Pinecone, Weviate, Milvus
    * Графовые
    * Базы данных для временных рядов
    * Поисковые базы данных (Search Engines)
    * Объектно-ориентированные базы данных
    * RDF (Resource Description Framework)
    * GEO/GIS (пространственные)
    * Event СУБД (баз данных переходов состояний)
    * И другие 
* Миграция базы данных: как обновлять структуру без downtime
* Резервное копирование и восстановление
* Комплаенс: GDPR, HIPAA (если требуется)
* [Теорема CAP](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_CAP) и [теорема PACELC](https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BE%D1%80%D0%B5%D0%BC%D0%B0_PACELC)

### **6. Масштабируемость и надежность**

* Масштабирование
    * Вертикальное масштабирование: Увеличение мощности сервера
    * Горизонтальное масштабирование: Добавление серверов
* Балансировка нагрузки
    * Балансировщик нагрузки (Load Balancer) - устройство или ПО, предназначенное для равномерного распределения входящего трафика среди нескольких серверов или сервисов
    * Может быть физическим сервером (горизонтальное масштабирование) или nginx сервером
    * Балансировщиков может быть несколько; они анализируют, какой сервер может принять нагрузку; некоторые из них могут прогнозировать нагрузку на сервис
    * [Алгоритмы балансировки нагрузок](https://habr.com/ru/companies/ruvds/articles/732648/)
    * Использование хэша для выбора сервера
* Распределение данных
    * Партицирование (секционирование) - распределение данных на разные машины
        * Вертикальное: разделение таблиы на смысловые части с последующим разнесением этих частей на разные машины
        * Горизонтальное: шардирование (sharding) - разделение таблицы на несколько независимых частей, шардов (shard — осколок) по какому-нибудь столбцу или индексу
    * Репликация и избыточность - дублирование критически важных данных
        * Кворум
        * Лидер и последователи
    * Консистентное (согласованное) хеширование
* Отказоустойчивость
    * Геораспределение (multi-region deployment)
    * Circuit breakers для предотвращения каскадных сбоев

### **7. Производительность**

* Генераия уникальных данных
    * UUID
* Кэширование часто используемых данных
    * Кэшировать можно что угодно: на фронтенде, ответы на популярные вопросы по API
    * Как решить, что кэшировать?
        * Принцип Парето: 80-20
        * 50-40-10
        * 79-20-1
    * Обычно кэш это дорого
    * Необходимо производить инвалидацию кэша (обновлять устаревший кэш)
        * First In First Out (FIFO)
        * Last In First Out (LIFO)
        * Least Recently Used (LRU)
        * Least Frequently Used (LFU)
* Оптимизация запросов к БД
    * Индексы
        * Значительно ускоряет чтение, но замедляет запись; если операция записи в приоритете, то не стоит использовать
        * Также недостатком является необходимость обновления индекса для всех данных
    * Хранимые процедуры
* Сжатие данных (gzip, Brotli)

### **8. Безопасность**

* Аутентификация: OAuth 2.0, JWT 
* Авторизация: RBAC (ролевой доступ)
* Шифрование: TLS для передачи данных, шифрование на уровне БД
* Защита от атак
    * SQL-инъекции
    * XSS
    * Brute-force
        * Ограничиваем количество запросов от одного пользователя/устройства/IP-адреса
        * Можно написать софт-ограничитель на стороне клиентского приложения или на стороне сервера
        * Лучшим решением является вынесение ограничителя в отдельный подсервис
        * [HL 2018. Конспект доклада «Make passwords great again! Как победить брутфорс и оставить хакеров ни с чем»](https://habr.com/ru/articles/434708/)
    * DDoS
        * Ограничение RPS
        * Сокрытие реального адреса сервера за прокси; если будет атака, то упадет прокси-сервер
        * Ограничение запросов от конкретных IP-адресов при помощи файервол (например Cloudflare)
        * Системы отслеживания трафика

### **9. Развертывание и инфраструктура**

* Облако: AWS, Google Cloud, Azure
* CI/CD: Jenkins, GitLab CI
* Контейнеризация: Docker, Kubernetes 

### **10. Тестирование и итерации**

* Нагрузочное тестирование (JMeter, Gatling)
* Проверка отказоустойчивости (Chaos Engineering)
* План для восстановления после сбоев
* A/B-тестирование для новых фич

### **11. Мониторинг**

* Выбор метрик мониторинга
    * Только такие, которые мы можем объяснить, и такие, на которые мы можем повлиять
    * Примеры: нагрузка, количество запросов, время ответа, отказы, распределение ошибок, 99% latency
* Мониторинг метрик: Grafana, DataDog, Prometheus, ELK-стек (логи)
* Хранить логи удобно в колоночной БД
* Логирование: Centralized logging (например, через Splunk)
