# Python cheat sheets

[Изучаем Python - Марк Лутц](https://docs.google.com/document/d/1EKhRqS1N47Ti61gp48spUvGehVx5_jJWHhvyqfD9xkY/edit?usp=sharing)

## Общие сведения:
* Python - высокоуровневый язык программирования общего назначения, скриптовый язык с динамической типизацией. 
* Автор: Гвидо ван Россум. 
* Низкая производительность, но высокая продуктивность. 
* The zen of Python - import this. 
* Python PEP8 - Style guide for Python.

## Интроспекция в Python
* Для любого объекта можно получить всю информацию о его внутренней структуре и среде исполнения + модуль inspect
* docstring - строки документации
* aaa.__doc__
* PyDoc - help( )
* Список всех атрибутов объекта - dir( )

## Функция print
```3.X: print([object, ...][sep=’’][, end=’\n’][, file = sys.stdout])```
* sep - строка, которая должна вставляться между объектами при выводе
* end - строка, вставляемая в конец текста
* file - файл / стандартный поток / другой объект, куда будет выводиться текст.

## Данные в Python
* Данные в Python представлены в виде объектов (встроенных или созданных). 
* По сути, объекты - это области памяти со значениями и ассоциированные с ними наборами операций. 
* Встроенная типизация = у каждого объекта есть свой тип, но нет необходимости указывать этот тип явно. 
* Типы данных определяются автоматически во время исполнения программы.

Категории типов (и операций) в Python:
* Числа
* Последовательности (строки, списки, кортежи)
* Отображения (словари)
* Множества

Типы данных:
* Неизменяемые: 
  * числа
  * строки
  * кортежи
  * фиксированные множества
* Изменяемые: 
  * списки
  * словари
  * множества

Хэшируемые объекты:
* Объекты, которые не изменяются в течении своей жизни.
* __hash__
* (1, 2, 3) - неизменяемый, хэшируемый
* (1, 2, [3]) - неизменяемый, нехэшируемый 
* type(x)

Соглашение по именованию:
* Имена, начинающиеся с одного символа подчеркивания _X не импортируются инструкцией from module import *
* Имена, имеющие два символа подчеркивания в начале и в конце __X__, являются системными именами.
* Имена, начинающиеся с двух символов подчеркивания __X являются локальными (“искаженными”) для объемлющего класса.
* Имя, состоящее из _ хранит результат последнего выражения при работе в интерактивной оболочке.

### Логические значения - Boolean
* True = 1, False = 0 - числа
* Числа отличные от 0 => True
* Другие непустые объекты => True
* Пустые => False
* None => False

### Строки
* ```'hello'[::-1] => 'olleh'``` - реверс строки ```S[::-1]```
* ```S[откуда : докуда : шаг]```

Существует несколько вариантов форматирования строк:
* с оператором % — более старый вариант: ```"interface %s" % ‘abc’``` ==> ```'interface abc'```
* метод format() — относительно новый вариант: ```"interface FastEthernet0/{}".format('1')``` ==> ```'interface FastEthernet0/1'```
* f-строки или интерполяция строк — новый вариант, который появился в Python 3.6. 
  F-строки позволяют не только подставлять какие-то значения в шаблон, но и позволяют выполнять вызовы функций, методов и т.п.

### Списки
Абстракции списков:
* [ i for i in arr ] - List
* ( i for i in arr) - Generator

```
(a, b, c) = “ABC”
a, c => (‘A’, ‘C’)
```

```
*a, b = [1, 2, 3, 4]
a => [1, 2, 3]
b => [4]
```

### Словари
Генератор словаря: ```{v: k for k, v in some_dict_items}```

## Файлы
Файл - именованная область постоянной памяти.

Прежде, чем работать с файлом, его надо открыть: ```f = open('text.txt', 'r')```.          
У функции open много параметров, пока важны 3 аргумента: 
* Путь до файла (может быть относительным или абсолютным)
* Режим открытия файла: могут быть объединены, то есть, к примеру, 'rb' - чтение в двоичном режиме. По умолчанию режим равен 'rt'
* Кодирование файла

## Тернарный оператор
```
fat = True
fitness = (‘худой’, ‘толстый’)[fat]
```

## Циклы
while:        
```
while <test1>:
    <statement1>
    if <test2>: break
    if <test3>: continue
else: <statement2>
```

for:        
```
for <target> in <object>:
    <statements1>
    if <test1>: break
    if <test2>: continue
else: <statements2>
```

range - встроенная функция, которая возвращает непрерывную последовательность целых чисел, которые можно использовать в качестве индексов внутри цикла for.
Range возвращает итератор, который генерирует элементы по требованию.

```
range(5) => [0, 1, 2, 3, 4]
range(2, 5) => [2, 3, 4]
range(0, 10, 2) => [0, 2, 4, 6, 8]
```

## Функции
* Функция - это объект. 
* Функции не имеют типа. 
* Максимизирование многократного использования кода и минимизирование его избыточности. 
* Процедурная декомпозиция.

def - инструкция, исполняемый программный код. Создает объект и присваивает ему имя. 
Аргументы передаются в функцию посредством присваивания (в виде ссылок на объекты).

```
def <name> (arg1, arg2, …, argN):
    <statements>
    return <value>  # None по умолчанию
```

### *args и **kwargs
В Python можно передать переменное количество аргументов двумя способами:
* *args для неименованных аргументов  - list, set и т д
    ```
    def adder(*nums):
     sum = 0
     for n in nums:
     sum += n
    
     print("Sum: ", sum)
    
    >>> adder(3, 5) => Sum: 8
    >>> adder(4, 5, 6, 7) => Sum: 22
    >>> adder(1, 2, 3, 5, 6) => Sum: 17
    ```
* **kwargs для именованных аргументов - dict
    ```
    def intro(**data):
     print("\nData type of argument: ",type(data))
    
     for key, value in data.items():
     print("{} is {}".format(key, value))
    
    >>> intro(Firstname="Sita", Lastname="Sharma", Age=22, Phone=123)
    >>> intro(Firstname="John", Lastname="W", Email="jw@n.com", Country="W", Age=25, Phone=9)
    ```
  
Если вы хотите использовать и *args, и **kwargs, то это делается так:                 
func(fargs, *args, **kwargs), порядок следования аргументов важен; fargs - формальные параметры.

### Правило LEGB (Local, Enclosing, Global и Built-in Scope)
* L - локальная область видимости: область содержит имена, определенные внутри функции или lambda-выражения
* E - нелокальная область видимости: область, которая существует только для вложенных функций; объемлющая область является областью действия внешней или объемлющей функции
* G - глобальная область видимости: область, содержащая все имена, определенные на уровне программы или модуля
* B - встроенная область: специальная область, которая создается или загружается при запуске скрипта или открытии интерактивного сеанса.

### Lambda (анонимная функция)
Выражение lambda создает объект функции в виде выражения и возвращает его в виде результата, не связывая его с именем.

```lambda arg1, arg2, ..., argN: <выражения>```

### Итерации и генераторы
Итераторы:
* Итерируемые объекты - (встроенные: списки, кортежи, строки) любые объекты, которые имеют метод __iter__ или __getitem__, 
   который возвращает итераторы или могут принимать индексы.
* Итератор - объект, который имеет метод next или __next__. В конце возбуждается исключение stopIteration. 
* next(X) ~ X.__next__( )
* Итерация - процесс получения элементов из какого-либо источника (например, списка).

Генераторы:
* Генератор - это итератор, который можно итерировать только один раз, его элементы не хранятся, а “генерируются”.
* Генератор хранит в памяти не все элементы,  а только внутреннее состояние для вычисления очередного элемента.
* Генераторное выражение - это выражение, возвращающее итератор генератора.

В языке Python имеются различные встроенные функции, позволяющие обрабатывать итерируемые объекты:
* zip 
  * Инструкция zip - встроенная функция; возвращает список кортежей, составленных из элементов входных списков с одинаковыми индексами, 
    который может использоваться для одновременного обхода нескольких последовательностей в цикле for.
  * По итераторам zip и map возможен всего один проход! zip, map - нет множественной поддержки итераторов, range - множественная поддержка итераторов.
    ```
    L1 = [1, 2, 3, 4]
    L2 = [5, 6, 7, 8]
    list(zip(L1, L2)) => [(1, 5), (2, 6), (3, 7), (4, 8)]
    
    L1 = ‘abc’
    L2 = ‘xyz123’
    list(zip(L1, L2)) => [(‘a’, ‘x’), (‘b’, ‘y’), (‘c’, ‘z’)]
    
    b = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    zip(*[b.__iter__()] * 3) => [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
    ```
* map 
  * Инструкция map применяет указанную функцию к каждому элементу указанной последовательности/последовательностей. 
  * map(func, iterable, ...) -> 3.0 iterator | list
    ```
    def func(el1, el2): 
        return '%s|%s' % (el1, el2)
    
    # python 2
    map(func, [1, 2], [3, 4, 5])  # ['1|3', '2|4', 'None|5']
    
    # python 3
    list(map(func, [1, 2], [3, 4, 5]))  # ['1|3', '2|4']
    # python 2
    dict(map(None, [1, 2], [3, 4]))  # {1: 3, 2: 4}
    
    # python 3
    dict(map(lambda *args: args, [1, 2], [3, 4]))  # {1: 3, 2: 4}
    ```
* enumerate: 
  * Инструкция enumerate - функция, которая возвращает объект-генератор. Она позволяет итерироваться по объекту с параллельным автоматическим счётчиком.
  * ```for c, value in enumerate(some_list): print(c, value)```
  * ```counter_list = list(enumerate(my_list, 1))```
* sorted 
* filter 
  * Инструкция filter принимает два параметра и возвращает объект-итератор.
  * Аргументы: функция, последовательность (строки, списки и кортежи), итератор или объект, поддерживающий итерацию. 
  * Функция filter() возвращает итератор, состоящий из тех элементов последовательности, 
    для которых переданная в качестве первого аргумента функция вернула истину (true) или ее аналог (не ноль, не пустую строку, не None).
    ```
    def func(x):
        if x > 0:
                return 1
        else:
                return 0
    
    >>> b = filter(func, [1, -4, 6, 8, -10])
    >>> b = list(b)
    >>> b ==> [1, 6, 8]
    ```
* reduce
  * Применяет указанную функцию к элементам последовательности, сводя её к единственному значению. 
  * reduce(function, iterable[, initializer])
  * Аргументы: аккумулированное ранее значение, следующий элемент последовательности.
  * Устарело в Python 3.0, если функция всё же требуется, то ее можно найти в functools.reduce().
  ```
  def reducer_func(el_prev, el):
      # el_prev — предшествующий элемент
      # el — текущий элемент
      return el_prev + el
  
  # python 2
  reduce(reducer_func, [1, 2, 3])  # 6
  
  # python 3
  from functools import reduce
  reduce(reducer_func, [1, 2, 3])  # 6
  ```
* sum 
* any 
* all 
* max 
* min

### Функции-генеаторы yield
* Выражение yield передает объект результата выполняющей программе и запоминает, где был произведен возврат.
* Функции-генераторы генерируют последовательность значений с течением времени.
* Функции-генераторы автоматически поддерживают протокол итераций.
* Функция-генератор поставляет значение, а не возвращает его - инструкций yield приостанавливает работу функции и передает значение вызывающей программе, 
  при этом сохраняя информацию о состоянии, чтобы возобновить работу с того места, где она была окончена.
* Функции-генераторы компилируют как генераторы, то есть при вызове такой функции будет поддерживаться метод __next__ (от yield до yield).

Итераторы файлов:    
* f.readline( ) - считывает строку (метод)
* f.__next__( ) - также метод, считывающий строку

Генераторы списков обычно в два раза быстрее циклов.

## Модули
* Инструкции
  * import - получает модуль целиком 
  * from - определяет имена из модуля 
  * as - изменение имени модуля 
  * name.method - повторная загрузка модуля без остановки интерпретатора 
* Импорт выполняется только один раз 
* Инструкции import и from - это операции присваивания 
* Инструкция import присваивает объект модуля единственному имени 
* Инструкция from присваивает одно и более имен объектам с теми же именами в другом модуле 
* Операция импортирования никогда не изменяет область видимости для кода в импортированном файле

### Пакет
Необходимо, чтобы в каждый каталог в пути содержал файл __init__.py. Он предназначен для выполнения действий по инициализации пакета.
